# SOLID Principles in Java üß©

This repository demonstrates the **SOLID principles** of Object-Oriented Design in **Java**, with practical examples for each principle.  
Every principle is illustrated with:
- ‚ùå A **wrong (violating)** implementation  
- ‚úÖ A **correct (refactored)** implementation  

This helps you clearly understand how to transform tightly coupled, hard-to-maintain code into **clean, modular, and extensible systems** ‚Äî just like we do in real-world backend projects.

---

### üìö What are SOLID Principles?

SOLID is an acronym that represents five key design principles introduced by Robert C. Martin (Uncle Bob).  
These principles help developers design **maintainable, scalable, and testable** object-oriented software.

| Principle | Description | Goal |
|------------|-------------|------|
| **S ‚Äì Single Responsibility Principle** | A class should have only one reason to change. | Separation of concerns |
| **O ‚Äì Open/Closed Principle** | Software should be open for extension but closed for modification. | Extensibility |
| **L ‚Äì Liskov Substitution Principle** | Subclasses should be substitutable for their base classes. | Reliable polymorphism |
| **I ‚Äì Interface Segregation Principle** | Clients should not be forced to depend on interfaces they don't use. | Focused abstractions |
| **D ‚Äì Dependency Inversion Principle** | Depend on abstractions, not concretions. | Flexible architecture |

---

### üß† Why This Repo?
This project is a hands-on guide to understand how to apply SOLID in real Java backend systems.  
Each folder includes both a **bad design (wrong)** and a **refactored design (correct)** to highlight practical improvements.

